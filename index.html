import React, { useMemo, useState } from "react";

// App de emparejamientos 3x3 para 6 jugadores
// - Introduce 6 nombres
// - Genera todos los partidos 3v3 (10 √∫nicos)
// - Orden aleatorio
// - Introducci√≥n secuencial de resultados
// - Clasificaci√≥n por jugador: 2 victoria, 1 empate, 0 derrota
// - Predicci√≥n del siguiente partido basada en puntos acumulados (modelo sencillo bayesiano con prior)

// Estilos Tailwind + UI minimalista
export default function App3x3VR() {
  const [names, setNames] = useState(["", "", "", "", "", ""]);
  const [started, setStarted] = useState(false);
  const [matches, setMatches] = useState([] as Match[]);
  const [currentIdx, setCurrentIdx] = useState(0);
  const [scoreA, setScoreA] = useState<string>("");
  const [scoreB, setScoreB] = useState<string>("");
  const [activeTab, setActiveTab] = useState<"jugadores" | "partido" | "clasificacion">("jugadores");

  type Match = {
    teamA: number[]; // √≠ndices de jugadores
    teamB: number[];
    scoreA?: number;
    scoreB?: number;
    result?: "A" | "B" | "D"; // draw
  };

  const allPlayersValid = useMemo(() => {
    const cleaned = names.map((n) => n.trim());
    if (cleaned.some((n) => n.length === 0)) return false;
    // comprobar duplicados (case-insensitive)
    const lower = cleaned.map((n) => n.toLowerCase());
    return new Set(lower).size === 6;
  }, [names]);

  function handleStart() {
    if (!allPlayersValid) return;
    const m = generateUniqueMatches();
    const shuffled = shuffle([...m]);
    setMatches(shuffled);
    setStarted(true);
    setCurrentIdx(0);
    setActiveTab("partido");
  }

  // Genera todas las combinaciones 3 de 6 y filtra duplicados (A vs B == B vs A)
  function generateUniqueMatches(): Match[] {
    const idx = [0, 1, 2, 3, 4, 5];
    const combos: number[][] = [];
    for (let a = 0; a < 4; a++) {
      for (let b = a + 1; b < 5; b++) {
        for (let c = b + 1; c < 6; c++) {
          combos.push([idx[a], idx[b], idx[c]]);
        }
      }
    }
    const matches: Match[] = [];
    for (const teamA of combos) {
      const teamB = idx.filter((i) => !teamA.includes(i));
      // criterio can√≥nico: m√≠nimo de A < m√≠nimo de B para evitar duplicados
      if (Math.min(...teamA) < Math.min(...teamB)) {
        matches.push({ teamA: [...teamA], teamB: [...teamB] });
      }
    }
    return matches; // 10 partidos
  }

  function shuffle<T>(arr: T[]): T[] {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Clasificaci√≥n por jugador (recalcula cada render)
  const standings = useMemo(() => {
    const pts = Array(6).fill(0) as number[];
    const pj = Array(6).fill(0) as number[];
    matches.forEach((m) => {
      if (m.result) {
        m.teamA.forEach((p) => (pj[p] += 1));
        m.teamB.forEach((p) => (pj[p] += 1));
        if (m.result === "A") {
          m.teamA.forEach((p) => (pts[p] += 2));
        } else if (m.result === "B") {
          m.teamB.forEach((p) => (pts[p] += 2));
        } else {
          // empate
          m.teamA.forEach((p) => (pts[p] += 1));
          m.teamB.forEach((p) => (pts[p] += 1));
        }
      }
    });
    return { pts, pj };
  }, [matches]);

  // Predicci√≥n del siguiente partido
  const prediction = useMemo(() => {
    // Mostrar predicci√≥n A PARTIR del partido 2 (√≠ndice 1)
    if (!started || currentIdx < 1 || currentIdx >= matches.length) return null;
    const m = matches[currentIdx];

    // Puntos acumulados antes del partido actual
    const ptsBefore = Array(6).fill(0) as number[];
    for (let i = 0; i < currentIdx; i++) {
      const mm = matches[i];
      if (!mm.result) continue;
      if (mm.result === "A") mm.teamA.forEach((p) => (ptsBefore[p] += 2));
      else if (mm.result === "B") mm.teamB.forEach((p) => (ptsBefore[p] += 2));
      else { mm.teamA.forEach((p) => (ptsBefore[p] += 1)); mm.teamB.forEach((p) => (ptsBefore[p] += 1)); }
    }

    const prior = 1;
    const rating = (i: number) => prior + ptsBefore[i];
    const sumA = m.teamA.reduce((acc, i) => acc + rating(i), 0);
    const sumB = m.teamB.reduce((acc, i) => acc + rating(i), 0);
    const diff = sumA - sumB;
    const probA = 1 / (1 + Math.exp(-diff / 2));
    const label = Math.abs(diff) < 0.75 ? "Partido muy igualado" : diff > 0 ? "Favorito: Equipo A" : "Favorito: Equipo B";

    // Estimaci√≥n de tanteo basada en promedios previos
    const finished = matches
      .slice(0, currentIdx)
      .filter((mm) => typeof mm.scoreA === "number" && typeof mm.scoreB === "number");
    const avgTotal = finished.length > 0
      ? finished.reduce((s, mm) => s + (mm.scoreA as number) + (mm.scoreB as number), 0) / finished.length
      : 12; // default si a√∫n no hay historial suficiente

    const confidence = Math.abs(probA - 0.5) * 2; // 0..1
    const margin = Math.max(1, Math.round(confidence * (avgTotal * 0.6)));

    let predA: number, predB: number;
    if (probA >= 0.5) { predA = Math.round(avgTotal / 2 + margin / 2); predB = Math.max(0, predA - margin); }
    else { predB = Math.round(avgTotal / 2 + margin / 2); predA = Math.max(0, predB - margin); }

    return { probA, probB: 1 - probA, label, predA, predB };
  }, [started, currentIdx, matches]);

  function submitScore() {() {
    if (currentIdx >= matches.length) return;
    const a = parseInt(scoreA, 10);
    const b = parseInt(scoreB, 10);
    if (Number.isNaN(a) || Number.isNaN(b)) return;
    const next = [...matches];
    const m = { ...next[currentIdx] };
    m.scoreA = a;
    m.scoreB = b;
    m.result = a > b ? "A" : a < b ? "B" : "D";
    next[currentIdx] = m;
    setMatches(next);
    setScoreA("");
    setScoreB("");
    if (currentIdx + 1 < next.length) {
      setCurrentIdx((i) => i + 1);
      setActiveTab("partido");
    } else {
      setCurrentIdx(next.length);
      setActiveTab("clasificacion");
    }
  }

  function undoLast() {
    if (currentIdx === 0) return;
    const idx = currentIdx - 1;
    const next = [...matches];
    next[idx] = { ...next[idx], scoreA: undefined, scoreB: undefined, result: undefined };
    setMatches(next);
    setCurrentIdx(idx);
    setActiveTab("partido");
  }

  function resetAll() {
    setStarted(false);
    setMatches([]);
    setCurrentIdx(0);
    setScoreA("");
    setScoreB("");
    setActiveTab("jugadores");
  }

  const remaining = started ? matches.slice(currentIdx) : [];
  const finished = started ? matches.slice(0, currentIdx) : [];

  const playerRows = useMemo(() => {
    return names
      .map((n, i) => ({
        name: n.trim() || `J${i + 1}`,
        pts: standings.pts[i] || 0,
        pj: standings.pj[i] || 0,
        ppp:
          (standings.pj[i] || 0) > 0
            ? (standings.pts[i] / standings.pj[i]).toFixed(2)
            : "-",
      }))
      .sort((a, b) => b.pts - a.pts || a.name.localeCompare(b.name));
  }, [names, standings]);

  const TabButton = ({ id, label }: { id: typeof activeTab; label: string }) => (
    <button
      onClick={() => setActiveTab(id)}
      className={`px-4 py-2 rounded-xl border text-sm font-medium transition ${
        activeTab === id
          ? "bg-blue-400 text-white border-blue-400"
          : "bg-blue-100 text-blue-900 border-blue-200 hover:bg-blue-200"
      }`}
    >
      {label}
    </button>
  );

  return (
    <div className="min-h-screen bg-slate-50 text-slate-900 p-6">
      <div className="max-w-5xl mx-auto">
        {/* Header */}
        <div className="bg-white rounded-2xl shadow p-5 mb-4">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
            <div>
              <h1 className="text-2xl font-bold">3√ó3 ‚Äì Generador, Predicci√≥n y Clasificaci√≥n</h1>
              <p className="text-sm text-slate-600">Introduce jugadores, juega los 10 partidos 3v3 y consulta predicciones y ranking.</p>
            </div>
            <div className="flex gap-2">
              <TabButton id="jugadores" label="Jugadores" />
              <TabButton id="partido" label="Partido y Predicci√≥n" />
              <TabButton id="clasificacion" label="Clasificaci√≥n" />
            </div>
          </div>
        </div>

        {/* Contenido por pesta√±as */}
        {activeTab === "jugadores" && (
          <div className="bg-white rounded-2xl shadow p-5">
            <h2 className="text-xl font-semibold mb-4">Introducir jugadores</h2>
            <div className="space-y-3">
              {names.map((val, i) => (
                <div key={i} className="flex items-center gap-2">
                  <span className="w-6 text-slate-500">{i + 1}.</span>
                  <input
                    className="flex-1 rounded-xl border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    placeholder={`Jugador ${i + 1}`}
                    value={val}
                    onChange={(e) => {
                      const next = [...names];
                      next[i] = e.target.value;
                      setNames(next);
                    }}
                  />
                </div>
              ))}
              <div className="flex items-center justify-between text-xs text-slate-500">
                <div>Partidos totales: {matches.length || 10} ¬∑ Jugados: {finished.length} ¬∑ Pendientes: {started ? remaining.length : 10}</div>
                <div className="flex gap-2">
                  <button onClick={resetAll} className="rounded-xl px-3 py-2 bg-slate-100 hover:bg-slate-200 border">Reiniciar</button>
                  <button
                    onClick={handleStart}
                    disabled={!allPlayersValid || started}
                    className={`rounded-xl px-4 py-2 font-semibold ${
                      !allPlayersValid || started
                        ? "bg-slate-300 text-slate-500 cursor-not-allowed"
                        : "bg-indigo-600 hover:bg-indigo-700 text-white"
                    }`}
                  >
                    Generar calendario y empezar
                  </button>
                </div>
              </div>
              {!allPlayersValid && (
                <p className="text-xs text-amber-600 mt-2">
                  Introduce los 6 nombres (sin repetir) para continuar.
                </p>
              )}
            </div>
          </div>
        )}

        {activeTab === "partido" && (
          <div className="bg-white rounded-2xl shadow p-5">
            <h2 className="text-xl font-semibold mb-4">Partido en curso ‚Äî Partido {currentIdx + 1} de {matches.length}</h2>
            {!started || currentIdx >= matches.length ? (
              <div className="text-slate-600">
                {!started ? "A√∫n no has iniciado la sesi√≥n" : "No quedan partidos pendientes. üéâ"}
              </div>
            ) : (
              <div className="space-y-4">
                {(() => {
                  const m = matches[currentIdx];
                  const teamA = m.teamA.map((i) => names[i]);
                  const teamB = m.teamB.map((i) => names[i]);
                  return (
                    <>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div className="rounded-xl border p-4">
                          <div className="uppercase text-xs text-slate-500 mb-1">Equipo A</div>
                          <ul className="list-disc ml-5">
                            {teamA.map((n, i) => (
                              <li key={i}>{n}</li>
                            ))}
                          </ul>
                        </div>
                        <div className="rounded-xl border p-4">
                          <div className="uppercase text-xs text-slate-500 mb-1">Equipo B</div>
                          <ul className="list-disc ml-5">
                            {teamB.map((n, i) => (
                              <li key={i}>{n}</li>
                            ))}
                          </ul>
                        </div>
                      </div>

                      {prediction && (
                        <div className="rounded-xl bg-indigo-50 border border-indigo-200 p-4">
                          <div className="text-sm font-semibold mb-1">Predicci√≥n del resultado</div>
                          <div className="text-sm">{prediction.label}</div>
                          <div className="text-xs text-slate-600 mt-1">Prob. A: {(prediction.probA * 100).toFixed(1)}% ¬∑ Prob. B: {(prediction.probB * 100).toFixed(1)}%</div>
                          <div className="text-sm mt-1">Previsi√≥n de tanteo: <span className="font-semibold">{prediction.predA} - {prediction.predB}</span></div>
                        </div>
                      )}% ¬∑ Prob. B: {(prediction.probB * 100).toFixed(1)}%</div>
                          <div className="text-xs text-slate-500">Fuerza A: {prediction.sumA.toFixed(2)} ¬∑ Fuerza B: {prediction.sumB.toFixed(2)} (prior = 1 + puntos acumulados)</div>
                        </div>
                      )}

                      <div className="flex items-end gap-3">
                        <div className="flex-1">
                          <label className="text-xs uppercase text-slate-500">Puntos equipo A</label>
                          <input
                            type="number"
                            min={0}
                            value={scoreA}
                            onChange={(e) => setScoreA(e.target.value)}
                            className="w-full rounded-xl border px-3 py-2"
                          />
                        </div>
                        <div className="flex-1">
                          <label className="text-xs uppercase text-slate-500">Puntos equipo B</label>
                          <input
                            type="number"
                            min={0}
                            value={scoreB}
                            onChange={(e) => setScoreB(e.target.value)}
                            className="w-full rounded-xl border px-3 py-2"
                          />
                        </div>
                        <button
                          onClick={submitScore}
                          className="rounded-xl px-4 py-2 bg-indigo-600 text-white font-semibold hover:bg-indigo-700"
                        >
                          Guardar resultado
                        </button>
                      </div>

                      <div className="flex gap-2">
                        <button onClick={() => setActiveTab("jugadores")} className="rounded-xl px-3 py-2 border">Editar jugadores</button>
                        <button onClick={() => setActiveTab("clasificacion")} className="rounded-xl px-3 py-2 border">Ver clasificaci√≥n</button>
                        <button onClick={undoLast} disabled={currentIdx === 0} className={`rounded-xl px-3 py-2 border ${currentIdx===0?"bg-slate-100 text-slate-400 cursor-not-allowed":"bg-white hover:bg-slate-50"}`}>Deshacer √∫ltimo</button>
                        <button onClick={resetAll} className="rounded-xl px-3 py-2 bg-slate-100 hover:bg-slate-200 border">Reiniciar</button>
                      </div>
                    </>
                  );
                })()}
              </div>
            )}
          </div>
        )}

        {activeTab === "clasificacion" && (
          <div className="space-y-6">
            <div className="bg-white rounded-2xl shadow p-5">
              <h2 className="text-xl font-semibold mb-4">Clasificaci√≥n individual</h2>
              {started ? (
                <div className="overflow-x-auto">
                  <table className="min-w-full text-sm">
                    <thead>
                      <tr className="text-left text-slate-600">
                        <th className="py-2">Jugador</th>
                        <th className="py-2">Pts</th>
                        <th className="py-2">PJ</th>
                        <th className="py-2">Pts/PJ</th>
                      </tr>
                    </thead>
                    <tbody>
                      {playerRows.map((r, i) => (
                        <tr key={i} className="border-t">
                          <td className="py-2 font-medium">{r.name}</td>
                          <td className="py-2">{r.pts}</td>
                          <td className="py-2">{r.pj}</td>
                          <td className="py-2">{r.ppp}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              ) : (
                <p className="text-slate-600 text-sm">Empieza la sesi√≥n para ver la clasificaci√≥n en vivo.</p>
              )}
              <div className="mt-4 flex gap-2">
                <button onClick={() => setActiveTab("partido")} className="rounded-xl px-3 py-2 border">Volver al partido</button>
                <button onClick={resetAll} className="rounded-xl px-3 py-2 bg-slate-100 hover:bg-slate-200 border">Reiniciar</button>
              </div>
            </div>

            {/* Historial */}
            {started && (
              <div className="bg-white rounded-2xl shadow p-5">
                <h2 className="text-xl font-semibold mb-4">Historial de partidos</h2>
                <div className="grid gap-3 md:grid-cols-2">
                  {matches.map((m, idx) => {
                  // Predicci√≥n previa al partido idx (en base a puntos antes de ese partido)
                  const ptsBefore = Array(6).fill(0) as number[];
                  for (let i = 0; i < idx; i++) {
                    const mm = matches[i];
                    if (!mm.result) continue;
                    if (mm.result === "A") mm.teamA.forEach((p)=>ptsBefore[p]+=2);
                    else if (mm.result === "B") mm.teamB.forEach((p)=>ptsBefore[p]+=2);
                    else { mm.teamA.forEach((p)=>ptsBefore[p]+=1); mm.teamB.forEach((p)=>ptsBefore[p]+=1); }
                  }
                  const prior = 1;
                  const rate = (i:number)=> prior + ptsBefore[i];
                  const sumA = m.teamA.reduce((a,i)=>a+rate(i),0);
                  const sumB = m.teamB.reduce((a,i)=>a+rate(i),0);
                  const fav = sumA - sumB >= 0 ? 'A' : 'B';

                  const isFinished = typeof m.scoreA === 'number' && typeof m.scoreB === 'number';
                  const upset = isFinished && m.result !== 'D' && ((m.result==='A' && fav==='B') || (m.result==='B' && fav==='A'));

                  return (
                    <div key={idx} className={`rounded-xl border p-3 ${idx < currentIdx ? (upset ? 'bg-red-100 border-red-200' : 'bg-emerald-50 border-emerald-200') : 'bg-slate-50'}`}>
                      <div className="text-xs text-slate-500 mb-1">Partido {idx + 1}</div>
                      <div className="text-sm">
                        <span className="font-semibold">A</span>: {m.teamA.map(i=>names[i]).join(", ")}<br />
                        <span className="font-semibold">B</span>: {m.teamB.map(i=>names[i]).join(", ")}
                      </div>
                      {isFinished ? (
                        <div className="mt-2 text-sm">
                          Marcador: <span className="font-semibold">{m.scoreA} - {m.scoreB}</span> ({m.result === 'A' ? 'Gana A' : m.result === 'B' ? 'Gana B' : 'Empate'})
                        </div>
                      ) : (
                        <div className="mt-2 text-xs text-slate-500">Pendiente</div>
                      )}
                    </div>
                  );
                })}
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

